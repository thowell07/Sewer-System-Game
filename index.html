<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dalton's Sewer System 2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { background-color: #3b2f2f; /* Deep dirt color */ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .dirt-pattern {
            background-image: radial-gradient(#4a3b3b 15%, transparent 16%), radial-gradient(#4a3b3b 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }
        @keyframes flush-spin {
            0% { transform: rotate(0deg) scale(1); }
            100% { transform: rotate(720deg) scale(0); }
        }
        .flushing { animation: flush-spin 1s ease-in forwards; }
        
        .water-flow {
            transition: all 0.3s linear;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONS & ASSETS ---
        
        const ToiletIcon = ({ isFlushing }) => (
            <div className="relative w-16 h-20 mx-auto">
                <div className="absolute top-0 left-2 w-12 h-8 bg-white border-2 border-gray-300 rounded-t-lg z-10"></div> {/* Tank */}
                <div className="absolute top-8 left-0 w-16 h-10 bg-white border-2 border-gray-300 rounded-b-2xl z-10 flex items-center justify-center overflow-hidden">
                    {/* Water in bowl */}
                    <div className={`w-10 h-6 bg-blue-300 rounded-full transition-all duration-1000 ${isFlushing ? 'flushing' : ''}`}></div>
                </div>
                <div className="absolute bottom-0 left-4 w-8 h-8 bg-gray-100 border-x-2 border-gray-300 z-0"></div> {/* Base */}
            </div>
        );

        const FactoryIcon = ({ fillLevel }) => (
            <div className="relative w-20 h-24 mx-auto flex flex-col items-center">
                <div className="w-full flex justify-center gap-1 mb-1">
                    <div className="w-2 h-8 bg-gray-400"></div>
                    <div className="w-2 h-6 bg-gray-400"></div>
                </div>
                <div className="w-20 h-16 bg-white border-4 border-blue-900 rounded-lg relative overflow-hidden">
                    <div 
                        className="absolute bottom-0 left-0 w-full bg-blue-500 transition-all duration-500 ease-out"
                        style={{ height: `${fillLevel}%` }}
                    >
                        <div className="w-full h-2 bg-blue-300 opacity-50 animate-pulse"></div>
                    </div>
                </div>
                <span className="text-xs text-white mt-1 font-bold tracking-wider">PURIFIER</span>
            </div>
        );

        // --- GAME LOGIC ---

        // Directions: 0:Up, 1:Right, 2:Down, 3:Left
        // Pipe Definitions: Which directions does this pipe connect?
        // Straight (Horizontal default): Connects Left(3) and Right(1)
        const PIPES = {
            straight: [1, 3], 
            corner: [2, 1], // Bottom-Right corner connects Down(2) and Right(1)
            cross: [0, 1, 2, 3],
            tshape: [1, 2, 3] // T pointing down
        };

        const LEVELS = [
            {
                id: 1,
                gridSize: 4,
                start: { r: 0, c: 0 }, // Top Left
                end: { r: 3, c: 3 },   // Bottom Right
                layout: [
                    { t: 'start', r: 0 }, { t: 'straight', r: 90 }, { t: 'corner', r: 180 }, { t: 'empty' },
                    { t: 'corner', r: 0 }, { t: 'corner', r: 270 }, { t: 'straight', r: 0 }, { t: 'empty' },
                    { t: 'straight', r: 0 }, { t: 'empty' }, { t: 'corner', r: 0 }, { t: 'straight', r: 90 },
                    { t: 'corner', r: 270 }, { t: 'straight', r: 90 }, { t: 'corner', r: 270 }, { t: 'end', r: 0 }
                ]
            },
            {
                id: 2,
                gridSize: 4,
                start: { r: 0, c: 1 }, 
                end: { r: 3, c: 1 },   
                layout: [
                    { t: 'corner', r: 0 }, { t: 'start', r: 0 }, { t: 'corner', r: 90 }, { t: 'empty' },
                    { t: 'straight', r: 0 }, { t: 'tshape', r: 0 }, { t: 'straight', r: 0 }, { t: 'empty' },
                    { t: 'empty' }, { t: 'straight', r: 0 }, { t: 'corner', r: 270 }, { t: 'corner', r: 180 },
                    { t: 'empty' }, { t: 'end', r: 0 }, { t: 'empty' }, { t: 'straight', r: 0 }
                ]
            }
        ];

        // Helper to get connected directions based on rotation
        const getConnections = (type, rotation) => {
            if (type === 'start') return [2]; // Down
            if (type === 'end') return [0];   // Up
            if (type === 'empty') return [];

            const baseDirs = PIPES[type];
            // Rotate directions: (dir + rotation/90) % 4
            const steps = rotation / 90;
            return baseDirs.map(d => (d + steps) % 4);
        };

        // Helper: Get opposite direction (Up <-> Down)
        const getOpposite = (dir) => (dir + 2) % 4;

        // Helper: Get next coordinate based on direction
        const getNextCoord = (r, c, dir) => {
            if (dir === 0) return { r: r - 1, c: c };
            if (dir === 1) return { r: r, c: c + 1 };
            if (dir === 2) return { r: r + 1, c: c };
            if (dir === 3) return { r: r, c: c - 1 };
            return { r, c };
        };

        export default function App() {
            const [levelIdx, setLevelIdx] = useState(0);
            const [grid, setGrid] = useState([]);
            const [gameState, setGameState] = useState('planning'); // planning, flushing, flowing, won, lost
            const [waterPath, setWaterPath] = useState([]); // Array of coordinates water has visited
            const [activeWaterIndex, setActiveWaterIndex] = useState(-1); // For animation
            const [tankFill, setTankFill] = useState(0);
            const [message, setMessage] = useState("Rotate the pipes to build the system!");

            // Init Level
            useEffect(() => {
                loadLevel(levelIdx);
            }, [levelIdx]);

            const loadLevel = (idx) => {
                const lvl = LEVELS[idx];
                const newGrid = lvl.layout.map((cell, i) => ({
                    ...cell,
                    id: i,
                    rotation: cell.t === 'start' || cell.t === 'end' ? cell.r : Math.floor(Math.random() * 4) * 90
                }));
                setGrid(newGrid);
                setGameState('planning');
                setWaterPath([]);
                setActiveWaterIndex(-1);
                setTankFill(0);
                setMessage("Connect the House to the Treatment Plant.");
            };

            const rotatePipe = (index) => {
                if (gameState !== 'planning') return;
                const cell = grid[index];
                if (cell.t === 'start' || cell.t === 'end' || cell.t === 'empty') return;

                const newGrid = [...grid];
                newGrid[index].rotation = (cell.rotation + 90) % 360;
                setGrid(newGrid);
            };

            const handleFlush = () => {
                if (gameState !== 'planning') return;
                setGameState('flushing');
                setMessage("FLUSHING! Here comes the waste...");
                
                // Calculate Path immediately
                const path = calculatePath();
                setWaterPath(path);
                
                // Start Animation sequence
                setTimeout(() => {
                    setGameState('flowing');
                    animateFlow(path, 0);
                }, 1000); // Wait for flush animation
            };

            const calculatePath = () => {
                const lvl = LEVELS[levelIdx];
                const size = lvl.gridSize;
                let path = [{ r: lvl.start.r, c: lvl.start.c, dir: 2 }]; // Start pushing DOWN
                let curr = { r: lvl.start.r, c: lvl.start.c };
                let incomingDir = null; // Came from nowhere initially

                // Simulation Loop (Safety break at 50 steps)
                for (let i = 0; i < 50; i++) {
                    const cellIdx = curr.r * size + curr.c;
                    const cell = grid[cellIdx];
                    
                    // 1. Get available exits for this cell
                    const exits = getConnections(cell.t, cell.rotation);
                    
                    // 2. Filter exits: Cannot go back where we came from
                    // If we entered from UP (dir 2), we can't exit UP (dir 0) unless dead end logic?
                    // Actually, simpler: We need to find the exit that ISN'T the entrance.
                    
                    let validExit = null;

                    if (cell.t === 'start') {
                        validExit = 2; // Always down
                    } else {
                        // We entered this cell from 'incomingDir'.
                        // So the entrance on this cell is getOpposite(incomingDir)
                        const entrance = getOpposite(incomingDir);
                        
                        // Check if this cell actually connects to that entrance
                        if (!exits.includes(entrance)) {
                            // Blockage! Water hit a wall on this tile.
                            return path; 
                        }

                        // Find the OTHER connection
                        validExit = exits.find(d => d !== entrance);
                    }

                    if (validExit === undefined) {
                        // Dead end or T-junction logic could be complex, for simplicity, if T-shape, pick straightest or first non-entry
                        // For this game, let's assume strictly 1-in-1-out flow for success, stops otherwise
                         return path;
                    }

                    // 3. Move to next cell
                    const nextPos = getNextCoord(curr.r, curr.c, validExit);
                    
                    // Check bounds
                    if (nextPos.r < 0 || nextPos.r >= size || nextPos.c < 0 || nextPos.c >= size) {
                        return path; // Flowed off map
                    }

                    // 4. Add to path
                    path.push({ r: nextPos.r, c: nextPos.c, dir: validExit });
                    
                    // 5. Check if we hit End
                    const nextIdx = nextPos.r * size + nextPos.c;
                    const nextCell = grid[nextIdx];
                    
                    if (nextCell.t === 'end') {
                         // Check if End tile accepts connection from this direction
                         // End accepts from UP (0). We are moving DOWN (2)? 
                         // Logic: End tile is usually fixed. Let's assume if we touch it, we check alignment.
                         const endAccepts = getConnections('end', nextCell.rotation);
                         const approachDir = getOpposite(validExit);
                         if (endAccepts.includes(approachDir)) {
                             // SUCCESS
                             return path;
                         } else {
                             // Hit the side of the factory
                             return path;
                         }
                    }

                    // Update for next loop
                    curr = nextPos;
                    incomingDir = validExit; // We are moving in this direction
                }
                return path;
            };

            const animateFlow = (path, step) => {
                if (step >= path.length) {
                    // Animation done. Check result.
                    const lastStep = path[path.length - 1];
                    const lvl = LEVELS[levelIdx];
                    if (lastStep.r === lvl.end.r && lastStep.c === lvl.end.c) {
                        handleWin();
                    } else {
                        handleLoss();
                    }
                    return;
                }

                setActiveWaterIndex(step);
                
                // Audio effect placeholder (visual only here)
                
                setTimeout(() => {
                    animateFlow(path, step + 1);
                }, 400); // Speed of water
            };

            const handleWin = () => {
                setGameState('won');
                setMessage("SYSTEM OPERATIONAL! Waste treated.");
                setTankFill(100);
            };

            const handleLoss = () => {
                setGameState('lost');
                setMessage("BLOCKAGE DETECTED! Oh no! Fix the pipes!");
            };

            const nextLevel = () => {
                if (levelIdx + 1 < LEVELS.length) {
                    setLevelIdx(levelIdx + 1);
                } else {
                    setMessage("ALL SYSTEMS COMPLETE! Master Plumber!");
                }
            };

            // --- RENDERERS ---

            const renderPipe = (cell, isWaterHere, isFlowing, isClean) => {
                const size = 100; // viewBox size
                const center = size / 2;
                const thickness = 30;
                
                // Color logic
                const pipeColor = "#555";
                const waterColor = isClean ? "#3B82F6" : "#8B4513"; // Blue if clean (won), Brown if waste
                
                // Determine paths based on type
                let d = "";
                // Simple shapes for SVG
                if (cell.t === 'straight') {
                     d = `M0 ${center-thickness/2} H${size} V${center+thickness/2} H0 Z`; // Horizontal bar
                } else if (cell.t === 'corner') {
                     // Bottom-Right corner: Connects Bottom and Right
                     d = `M${center-thickness/2} ${size} V${center-thickness/2} H${size} V${center+thickness/2} H${center+thickness/2} V${size} Z`;
                } else if (cell.t === 'tshape') {
                     // T shape: Left, Right, Bottom
                     d = `M0 ${center-thickness/2} H${size} V${center+thickness/2} H${center+thickness/2} V${size} H${center-thickness/2} V${center+thickness/2} H0 Z`;
                } else if (cell.t === 'cross') {
                     d = `M0 ${center-thickness/2} H${size} V${center+thickness/2} H0 Z M${center-thickness/2} 0 V${size} H${center+thickness/2} V0 Z`;
                }

                return (
                    <div 
                        className="w-full h-full transition-transform duration-300 relative"
                        style={{ transform: `rotate(${cell.rotation}deg)` }}
                    >
                        <svg viewBox="0 0 100 100" className="w-full h-full drop-shadow-md">
                            {/* Pipe Body */}
                            <path d={d} fill={pipeColor} stroke="#333" strokeWidth="2" />
                            
                            {/* Pipe Details (Bolts) */}
                            <circle cx="50" cy="50" r="8" fill="#444" />
                        </svg>
                        
                        {/* WATER OVERLAY */}
                        {isWaterHere && (
                            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-10">
                                <div className={`w-8 h-8 rounded-full shadow-lg transform transition-all duration-300 ${isClean ? 'bg-blue-400' : 'bg-yellow-800'}`}></div>
                            </div>
                        )}
                    </div>
                );
            };

            return (
                <div className="min-h-screen dirt-pattern flex flex-col items-center py-8 px-4 text-white">
                    
                    {/* Header HUD */}
                    <div className="w-full max-w-lg bg-gray-800 border-4 border-gray-600 rounded-xl p-4 mb-6 shadow-2xl flex justify-between items-center z-20">
                        <div>
                            <h1 className="text-xl font-bold text-yellow-400 uppercase tracking-widest">Sewer Sim 2.0</h1>
                            <div className="text-sm text-gray-300">{message}</div>
                        </div>
                        <div className={`w-4 h-4 rounded-full ${gameState === 'planning' ? 'bg-red-500' : 'bg-green-500 animate-pulse'}`}></div>
                    </div>

                    <div className="flex flex-col md:flex-row gap-4 items-center justify-center w-full max-w-4xl">
                        
                        {/* HOUSE CARD */}
                        <div className="bg-orange-100 rounded-xl p-4 border-4 border-orange-300 text-center w-40 shadow-xl flex flex-col justify-between h-64">
                            <div className="font-bold text-orange-800 mb-2">THE HOUSE</div>
                            <ToiletIcon isFlushing={gameState === 'flushing'} />
                            <button 
                                onClick={handleFlush}
                                disabled={gameState !== 'planning'}
                                className={`mt-4 w-full py-3 rounded-lg font-bold text-white shadow-md transition-transform active:scale-95
                                    ${gameState === 'planning' ? 'bg-red-600 hover:bg-red-500 border-b-4 border-red-800' : 'bg-gray-400 cursor-not-allowed'}
                                `}
                            >
                                {gameState === 'planning' ? 'FLUSH!' : 'Wait...'}
                            </button>
                        </div>

                        {/* GAME GRID */}
                        <div className="bg-gray-900 p-4 rounded-xl border-8 border-gray-700 shadow-2xl relative">
                            <div 
                                className="grid gap-1"
                                style={{ 
                                    gridTemplateColumns: `repeat(${LEVELS[levelIdx].gridSize}, minmax(0, 1fr))`,
                                    width: '320px',
                                    height: '320px'
                                }}
                            >
                                {grid.map((cell, idx) => {
                                    // Check if water is currently in this cell
                                    const pathIndex = waterPath.findIndex(p => p.r * LEVELS[levelIdx].gridSize + p.c === idx);
                                    const isWaterHere = pathIndex !== -1 && pathIndex <= activeWaterIndex;
                                    const isHead = pathIndex === activeWaterIndex; // The leading edge of water
                                    const isClean = gameState === 'won'; // Turn blue on win

                                    return (
                                        <div 
                                            key={idx}
                                            onClick={() => rotatePipe(idx)}
                                            className={`
                                                relative w-full h-full rounded flex items-center justify-center overflow-visible
                                                ${cell.t === 'empty' ? 'bg-transparent' : 'bg-gray-800/50 hover:bg-gray-700 cursor-pointer'}
                                            `}
                                        >
                                            {cell.t !== 'empty' && renderPipe(cell, isHead, gameState !== 'planning', isClean)}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* FACTORY CARD */}
                        <div className="bg-blue-100 rounded-xl p-4 border-4 border-blue-300 text-center w-40 shadow-xl flex flex-col justify-between h-64">
                            <div className="font-bold text-blue-900 mb-2">TREATMENT</div>
                            <FactoryIcon fillLevel={tankFill} />
                            
                            {gameState === 'won' && (
                                <button 
                                    onClick={nextLevel}
                                    className="mt-4 w-full py-3 rounded-lg font-bold text-white bg-green-500 hover:bg-green-400 border-b-4 border-green-700 shadow-md animate-bounce"
                                >
                                    NEXT LEVEL
                                </button>
                            )}
                            {gameState === 'lost' && (
                                <button 
                                    onClick={() => loadLevel(levelIdx)}
                                    className="mt-4 w-full py-3 rounded-lg font-bold text-white bg-yellow-500 hover:bg-yellow-400 border-b-4 border-yellow-700 shadow-md"
                                >
                                    TRY AGAIN
                                </button>
                            )}
                            {gameState !== 'won' && gameState !== 'lost' && (
                                <div className="mt-4 text-xs text-blue-400 font-mono">WAITING FOR INPUT...</div>
                            )}
                        </div>

                    </div>
                    
                    {/* Educational Footer */}
                    <div className="mt-8 text-center opacity-75">
                         <p className="text-yellow-100 text-sm">Use the pipes to guide the waste to the purifier.</p>
                         <p className="text-gray-400 text-xs mt-1">Brown Water = Dirty | Blue Water = Clean</p>
                    </div>

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
